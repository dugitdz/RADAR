clc; clear; close all;

%% ========================== PATHS (3 DUPLAS) ==========================
BASE = "C:\Users\eduar\UTFPR\IC\RADAR\PROJ_ESP32\output\";
DATASETS = [ ...
    struct("name","H2",  "radar", BASE+"phases.csv",     "polar", BASE+"POLARH2.txt"), ...
    struct("name","H3",  "radar", BASE+"phases_raw.csv", "polar", BASE+"POLARH3.txt"), ...
    struct("name","H10", "radar", BASE+"phase.csv",      "polar", BASE+"POLARH10.txt") ...
];

%% ===================== FIXOS =====================
GAP_THR_SEC = 0.6;
FS_TARGET   = 50.0;

COL_T_MS   = 1;
COL_HEART  = 2;

DT_GRID        = 0.1;
SMOOTH_HR_SEC  = 7.0;
F_MIN_HZ       = 0.05;

MIN_POINTS_AFTER_RESAMPLE = 32;
MIN_METRIC_SAMPLES        = 10;

CFG.N      = 64;
CFG.hop    = 16;
CFG.WRAP   = 0;

CFG.win    = "flattop";
CFG.ftype  = "cheby2";
CFG.ford   = 4;
CFG.wi     = 0.80;
CFG.wf     = 2.00;

CFG.harm_on    = 1;
CFG.harm_max   = 3;
CFG.harm_tol   = 1;
CFG.harm_ratio = 0.20;

fprintf('\n==================== CONFIG DEFINITIVA ====================\n');
fprintf('N=%d hop=%d WRAP=%d win=%s | filt=%s ord=%d wi=%.2f wf=%.2f | harm=%d (max=%d tol=%d ratio=%.2f)\n', ...
    CFG.N, CFG.hop, CFG.WRAP, CFG.win, CFG.ftype, CFG.ford, CFG.wi, CFG.wf, ...
    CFG.harm_on, CFG.harm_max, CFG.harm_tol, CFG.harm_ratio);

%% ===================== RUN =====================
Corrs = []; MAEs = []; RMSEs = []; used = 0;

fprintf('\n==================== RUN (DEFINITIVO) ====================\n');
for d = 1:numel(DATASETS)
    fprintf('\n[DATASET] %s\n', DATASETS(d).name);

    A    = readmatrix(DATASETS(d).radar);
    t_ms = A(:,COL_T_MS);
    xraw = A(:,COL_HEART);

    t0   = (t_ms - t_ms(1))/1000;
    seg0 = segment_by_gaps(t0, GAP_THR_SEC);

    try
        [t_polar, HR_polar] = read_txt_polar(DATASETS(d).polar);
        [t_polar, ia] = unique(t_polar,'stable');
        HR_polar = HR_polar(ia);
        hasPolar = ~isempty(t_polar) && ~isempty(HR_polar);
    catch
        hasPolar = false;
    end
    if ~hasPolar
        fprintf(' [SKIP] Polar indisponível.\n');
        continue;
    end

    if CFG.WRAP
        x0 = wrap_phase(xraw);
    else
        x0 = prep_nowrap(xraw);
    end

    [t_u, x_u] = resample_segments_irregular(t0, x0, seg0, FS_TARGET, 'linear');
    if numel(x_u) < max(MIN_POINTS_AFTER_RESAMPLE, CFG.N)
        fprintf(' [SKIP] Poucos pontos após resample: %d\n', numel(x_u));
        continue;
    end

    x_f = zero_phase_bandpass_cheby2(x_u, FS_TARGET, CFG.wi, CFG.wf, CFG.ford);

    [t_frames, f_hz] = rfft_fundamental_track_hop(t_u, x_f, FS_TARGET, ...
        CFG.N, CFG.hop, F_MIN_HZ, ...
        CFG.harm_on, CFG.harm_max, CFG.harm_tol, CFG.harm_ratio);

    if isempty(t_frames)
        fprintf(' [SKIP] Track vazio.\n');
        continue;
    end

    hr_bpm = 60 * f_hz;

    t_start = max(min(t_frames), min(t_polar));
    t_end   = min(max(t_frames), max(t_polar));
    if ~(isfinite(t_start) && isfinite(t_end) && t_end > t_start)
        fprintf(' [SKIP] Janela comum inválida.\n');
        continue;
    end

    t_common       = (t_start:DT_GRID:t_end)';
    HR_radar_grid  = smooth_in_time_to_grid(t_frames, hr_bpm, t_common, DT_GRID, SMOOTH_HR_SEC);
    HR_polar_grid  = interp_common(t_polar, HR_polar, t_common);

    [MAE, RMSE, R, n] = metrics(HR_radar_grid, HR_polar_grid);
    if ~(isfinite(MAE) && isfinite(R) && n >= MIN_METRIC_SAMPLES)
        fprintf(' [SKIP] Métrica inválida (n=%d).\n', n);
        continue;
    end

    used = used + 1;
    Corrs(end+1,1) = R; %#ok<AGROW>
    MAEs(end+1,1)  = MAE; %#ok<AGROW>
    RMSEs(end+1,1) = RMSE; %#ok<AGROW>

    fprintf(' OK | corr=%.4f | MAE=%.3f | RMSE=%.3f | n=%d\n', R, MAE, RMSE, n);

    figure('Name', "DEFINITIVO - "+DATASETS(d).name);
    plot(t_common, HR_polar_grid); hold on;
    plot(t_common, HR_radar_grid);
    grid on; xlabel('t (s)'); ylabel('HR (bpm)');
    legend('Polar (grid)','Radar (grid)');
    title(sprintf('DEFINITIVO %s | corr=%.3f MAE=%.2f RMSE=%.2f', DATASETS(d).name, R, MAE, RMSE));
end

fprintf('\n==================== SUMMARY ====================\n');
if used == 0
    fprintf('Nenhum dataset válido.\n');
else
    fprintf('Datasets usados: %d/%d\n', used, numel(DATASETS));
    fprintf('corr_mean=%.4f | MAE_mean=%.3f | RMSE_mean=%.3f\n', mean(Corrs), mean(MAEs), mean(RMSEs));
end

%% ========================== FUNÇÕES ==========================
function x = prep_nowrap(x)
x = double(x(:));
ok = isfinite(x);
if ~all(ok)
    x(~ok) = interp1(find(ok), x(ok), find(~ok), 'linear', 'extrap');
end
x = x - mean(x,'omitnan');
end

function ph_wrapped = wrap_phase(ph)
ph = double(ph(:));
ok = isfinite(ph);
if ~all(ok)
    ph(~ok) = interp1(find(ok), ph(ok), find(~ok), 'linear', 'extrap');
end
ph_wrapped = mod(ph + pi, 2*pi) - pi;
ph_wrapped = ph_wrapped - mean(ph_wrapped,'omitnan');
end

function segments = segment_by_gaps(t, gap_thr)
t = t(:);
n = numel(t);
if n < 2, segments = [1 n]; return; end
breaks = find(diff(t) > gap_thr);
if isempty(breaks)
    segments = [1 n];
else
    segments = [[1; breaks+1], [breaks; n]];
end
end

function [t_u, x_u] = resample_segments_irregular(t, x, segments, fs_target, method)
t = t(:); x = x(:);
dt = 1/fs_target;
t_u = []; x_u = [];
for k = 1:size(segments,1)
    i0 = segments(k,1); i1 = segments(k,2);
    ts = t(i0:i1); xs = x(i0:i1);
    [ts, iu] = unique(ts,'stable'); xs = xs(iu);
    if numel(ts) < 4, continue; end
    tnew = (ts(1):dt:ts(end))';
    xnew = interp1(ts, xs, tnew, method);
    ok = isfinite(tnew) & isfinite(xnew);
    t_u = [t_u; tnew(ok)]; %#ok<AGROW>
    x_u = [x_u; xnew(ok)]; %#ok<AGROW>
end
[t_u, iu] = unique(t_u,'stable');
x_u = x_u(iu);
end

function y = zero_phase_bandpass_cheby2(x, fs, wi_hz, wf_hz, order_final)
x = x(:);
if numel(x) < 16 || wf_hz >= fs/2 || wi_hz <= 0 || wi_hz >= wf_hz || mod(order_final,2)~=0
    y = x; return;
end
n = order_final/2;
Rs = 30;
[b,a] = cheby2(n, Rs, [wi_hz wf_hz]/(fs/2), 'bandpass');
padlen = 3*(max(length(a), length(b)) - 1);
if numel(x) <= padlen, y = x; return; end
y = filtfilt(b,a,x);
end

function [t_frames, fpk_hz] = rfft_fundamental_track_hop(tu, xu, fs, nperseg, hop, f_min_hz, harm_on, harm_max_order, harm_tol_bins, harm_ratio_min)
tu = tu(:); xu = xu(:);
if numel(xu) < nperseg || numel(tu) ~= numel(xu)
    t_frames = []; fpk_hz = []; return;
end
win = flattopwin(nperseg,'periodic');
nfft = nperseg;
k_min = ceil(f_min_hz * nfft / fs); k_min = max(2, k_min);

t_frames = []; fpk_hz = [];
idx0 = 1;
while (idx0 + nperseg - 1) <= numel(xu)
    xw = xu(idx0:idx0+nperseg-1) .* win;
    xw = xw - mean(xw,'omitnan');
    X  = fft(xw, nfft);
    half = floor(nfft/2) + 1;
    P = abs(X(1:half)).^2;

    if k_min > numel(P), idx0 = idx0 + hop; continue; end
    [~, rel] = max(P(k_min:end));
    k0 = k_min + rel - 1;

    if harm_on
        k0 = harmonic_guard_pick_subharmonic(P, k0, k_min, harm_max_order, harm_tol_bins, harm_ratio_min);
    end

    delta = parabolic_peak_interp_logP(P, k0);
    f_est = (k0 - 1 + delta) * fs / nfft;
    t_center = tu(idx0) + 0.5*(nperseg-1)/fs;

    t_frames(end+1,1) = t_center; %#ok<AGROW>
    fpk_hz(end+1,1)   = f_est;    %#ok<AGROW>
    idx0 = idx0 + hop;
end
end

function k_pick = harmonic_guard_pick_subharmonic(P, k0, k_min, max_order, tol_bins, ratio_min)
k_pick = k0;
P0 = P(k0);
if ~isfinite(P0) || P0 <= 0, return; end
for m = 2:max_order
    k_est = round(k0 / m);
    if k_est < k_min, continue; end
    lo = max(k_min, k_est - tol_bins);
    hi = min(numel(P), k_est + tol_bins);
    [Psub, idx] = max(P(lo:hi));
    ksub = lo + idx - 1;
    if isfinite(Psub) && (Psub >= ratio_min * P0)
        k_pick = ksub;
        P0 = Psub;
    end
end
end

function delta = parabolic_peak_interp_logP(P, k)
if k <= 1 || k >= numel(P), delta = 0; return; end
la = log(P(k-1) + 1e-20);
lb = log(P(k)   + 1e-20);
lc = log(P(k+1) + 1e-20);
den = (la - 2*lb + lc);
if den == 0 || ~isfinite(den), delta = 0; return; end
delta = 0.5*(la - lc)/den;
if ~isfinite(delta), delta = 0; end
delta = max(-0.75, min(0.75, delta));
end

function y_grid = smooth_in_time_to_grid(t_src, y_src, t_grid, dt_grid, smooth_sec)
y_i = interp_common(t_src, y_src, t_grid);
win_n = max(1, round(smooth_sec/dt_grid));
y_grid = movmean(y_i, win_n, 'omitnan');
end

function out = interp_common(t_src, y_src, t_dst)
t_src = t_src(:); y_src = y_src(:); t_dst = t_dst(:);
ok = isfinite(t_src) & isfinite(y_src);
out = nan(size(t_dst));
if sum(ok) < 2, return; end
out = interp1(t_src(ok), y_src(ok), t_dst, 'linear', nan);
end

function [MAE, RMSE, R, n] = metrics(yhat, yref)
m = isfinite(yhat) & isfinite(yref);
n = sum(m);
if n < 3, MAE = nan; RMSE = nan; R = nan; return; end
e = yhat(m) - yref(m);
MAE = mean(abs(e));
RMSE = sqrt(mean(e.^2));
R = corr(yhat(m), yref(m));
end

function [t_sec, HR] = read_txt_polar(p)
fid = fopen(p,'r');
if fid == -1, error('Não foi possível abrir o arquivo Polar.'); end
C = textscan(fid,'%s %f %*[^\n]','Delimiter',';','HeaderLines',1);
fclose(fid);
ts_str = C{1};
HR     = C{2};
try
    t_dt = datetime(ts_str,'InputFormat','yyyy-MM-dd''T''HH:mm:ss.SSS');
catch
    t_dt = datetime(ts_str,'InputFormat','yyyy-MM-dd HH:mm:ss.SSS');
end
t_sec = seconds(t_dt - t_dt(1));
end
